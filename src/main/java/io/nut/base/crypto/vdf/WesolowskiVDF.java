/*
 *  WesolowskiVDF.java
 *
 *  Copyright (c) 2025 francitoshi@gmail.com
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  Report bugs or new features to: francitoshi@gmail.com
 */
package io.nut.base.crypto.vdf;

import io.nut.base.crypto.Kripto;
import io.nut.base.math.Primes;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.concurrent.TimeUnit;

public class WesolowskiVDF
{

    private static final BigInteger TWO = BigInteger.valueOf(2);
    private static final SecureRandom RANDOM = new SecureRandom();

    private final Kripto kripto;
    public final BigInteger n; // Public RSA module (Order unknown)

    public WesolowskiVDF(Kripto kripto, BigInteger n)
    {
        this.kripto = (kripto == null) ? Kripto.getInstance() : kripto;
        this.n = n;
    }

    public WesolowskiVDF(BigInteger n)
    {
        this(null, n);
    }

    /**
     * Creates an instance by generating new RSA keys (For configuration
     * purposes only). In a real-world environment, 'n' would be public and
     * generated by a secure ceremony (Trusted Setup) or using RSA-2048 from
     * cryptography labs.
     * @param kripto
     * @param bits
     * @return 
     */
    public static WesolowskiVDF create(Kripto kripto, int bits)
    {
        // Generación simple de claves para el ejemplo.
        // En producción usar generadores de "Safe Primes" robustos.
        BigInteger p = Primes.safePrime(bits);
        BigInteger q = Primes.safePrime(bits);
        BigInteger N = p.multiply(q);
        return new WesolowskiVDF(kripto, N);
    }

    /**
     * Creates an instance by generating new RSA keys (For configuration
     * purposes only). In a real-world environment, 'n' would be public and
     * generated by a secure ceremony (Trusted Setup) or using RSA-2048 from
     * cryptography labs.
     * @param bits
     * @return 
     */
    public static WesolowskiVDF create(int bits)
    {
        return create(null, bits);
    }

    public BigInteger createChallenge()
    {
        BigInteger x = new BigInteger(n.bitLength(), RANDOM).mod(n);
        while (x.compareTo(TWO) < 0)
        {
            x = new BigInteger(n.bitLength(), RANDOM).mod(n);
        }
        return x;
    }

    /**
     * EVALUATION + TEST GENERATION This process is inherently sequential and
     * slow.
     *
     * @param x The initial value (seed)
     * @param t The time parameter (number of square iterations)
     * @return 'y' (result) and 'pi' (test)
     */
    public BigInteger[] solve(BigInteger x, int t)
    {
        // 1. Calculate y = x^(2^t) mod N
        // This is the actual "Delay". It cannot be parallelized.
        BigInteger y = x;
        for (int i = 0; i < t; i++)
        {
            y = y.multiply(y).mod(n);
        }

        // 2. Proof generation
        // We use Fiat-Shamir to generate a prime 'l' based on x and y
        BigInteger l = hashToPrime(x, y);

        // 3. Calculate the exponent of the test: Q = floor(2^t / l)
        // NOTE: For very large t, explicitly calculating 2^t consumes a lot of memory.
        // Production implementations use optimized long division algorithms.
        BigInteger twoToT = TWO.pow(t);
        BigInteger q = twoToT.divide(l);

        // 4. Calculate pi = x^Q mod N
        BigInteger pi = x.modPow(q, n);

        return new BigInteger[]
        {
            y, pi
        };
    }

    /**
     * VERIFICATION This process is extremely fast regardless of how large 't'
     * is.
     *
     * Equation to verify: pi^l * x^r == y (mod N) where r = 2^t mod l
     */
    public boolean verify(BigInteger x, int t, BigInteger[] yPi)
    {
        if (yPi == null || yPi.length != 2)
        {
            throw new IllegalArgumentException("Invalid proof format");
        }
        if (x == null || x.compareTo(BigInteger.ONE) <= 0 || x.compareTo(n) >= 0)
        {
            throw new IllegalArgumentException("Invalid challenge");
        }
        if (t <= 0)
        {
            throw new IllegalArgumentException("Time parameter must be positive");
        }

        BigInteger y = yPi[0];
        BigInteger pi = yPi[1];

        // 1. Reconstruct the prime 'l' using the public data
        BigInteger l = hashToPrime(x, y);

        // 2. Calculate r = 2^t mod l
        // This is quick because the modulus 'l' is relatively small.
        BigInteger r = TWO.modPow(BigInteger.valueOf(t), l);

        // 3. Verify the Wesolowski equation:
        // pi^l * x^r = (x^Q)^l * x^r = x^(Q*l + r) = x^(2^t) = y
        BigInteger lhs1 = pi.modPow(l, n);      // pi^l
        BigInteger lhs2 = x.modPow(r, n);       // x^r
        BigInteger resultToCheck = lhs1.multiply(lhs2).mod(n);

        return resultToCheck.equals(y);
    }

    // Utility method for benchmarks (similar to your original code)
    public int delayUnitsPerMillisecond(int testMillis)
    {
        BigInteger x = createChallenge();

        final long testNanos = TimeUnit.MILLISECONDS.toNanos(testMillis);

        long startNanos = System.nanoTime();
        long stopWarmUp = startNanos + (testNanos / 10);
        long stopTester = startNanos + testNanos;
        long lastNanos = startNanos;

        int i=0;
        int t=1;
        
        for(;(lastNanos=System.nanoTime())<stopWarmUp && i<31;i++,t*=2)
        {
            solve(x, t);
        }

        long startTester = lastNanos;
        long count = 0;

        for(;(lastNanos=System.nanoTime())<stopTester && i<31 ;i++,t*=2)
        {
            solve(x, t);
            count += t;
        }

        long nanos = lastNanos-startTester;
        long millis = TimeUnit.NANOSECONDS.toMillis(nanos);

        return millis == 0 ? 1 : (int) (count / millis);
    }

    // 128 bits is the recommended standard for the proof prime in Wesolowski.
    // It offers 128-bit security against forgery and makes verification very fast.
    private static final int PRIME_BITS = 128;
    private static final int PRIME_BYTES = PRIME_BITS / 8;

    /**
     * Generates a deterministic prime number based on the inputs using the
     * Fiat-Shamir heuristic with a "Hash-and-Increment" strategy.
     *
     * @param x The initial challenge (seed)
     * @param y The calculated result
     * @return A BigInteger that is prime with a very high probability.
     */
    public BigInteger hashToPrime(BigInteger x, BigInteger y)
    {
        // 1. We prepare the base hash with the inputs x and y.
        MessageDigest baseDigest = kripto.sha256.get();

        // We normalize the BigIntegers to (unsigned) byte arrays for consistency
        byte[] xBytes = bigIntegerToUnsignedBytes(x);
        byte[] yBytes = bigIntegerToUnsignedBytes(y);

        // Preparar el estado base
        baseDigest.update(xBytes);
        baseDigest.update(yBytes);

        long nonce = 0;
        byte[] nonceBytes = new byte[Long.BYTES];

        while (true)
        {
            MessageDigest roundDigest;
            try
            {
                roundDigest = (MessageDigest) baseDigest.clone();
            }
            catch (CloneNotSupportedException e)
            {
                roundDigest = kripto.sha256.get();
                roundDigest.update(xBytes);
                roundDigest.update(yBytes);
            }

            longToBytes(nonce, nonceBytes);
            roundDigest.update(nonceBytes);

            byte[] hash = roundDigest.digest();
            byte[] candidateBytes = Arrays.copyOfRange(hash, 0, PRIME_BYTES);

            BigInteger candidate = new BigInteger(1, candidateBytes);
            candidate = candidate.setBit(PRIME_BITS - 1);
            candidate = candidate.setBit(0);

            if (candidate.isProbablePrime(100))
            {
                return candidate;
            }

            nonce++;
        }
    }

    private void longToBytes(long value, byte[] dest)
    {
        for (int i = 7; i >= 0; i--)
        {
            dest[i] = (byte) (value & 0xFF);
            value >>= 8;
        }
    }

    /**
     * Utility to convert BigInteger to a byte array without the extra sign byte
     * that Java usually adds. This ensures consistency across
     * platforms/languages.
     */
    private static byte[] bigIntegerToUnsignedBytes(BigInteger val)
    {
        byte[] bytes = val.toByteArray();
        if (bytes[0] == 0)
        {
            byte[] tmp = new byte[bytes.length - 1];
            System.arraycopy(bytes, 1, tmp, 0, tmp.length);
            return tmp;
        }
        return bytes;
    }

}
