/*
 *  AesGcmSerializer.java
 *
 *  Copyright (c) 2025 francitoshi@gmail.com
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  Report bugs or new features to: francitoshi@gmail.com
 */
package io.nut.base.crypto;

import io.nut.base.crypto.Kripto.Hmac;
import io.nut.base.crypto.Kripto.SecretKeyTransformation;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.util.Arrays;

/**
 * Implements the {@link BytesCipher} interface using a deterministic scheme
 * based on AES/CTR/NoPadding and a synthetic IV.
 * <p>
 * This implementation provides deterministic encryption, meaning the same
 * plaintext will always result in the same ciphertext. This is useful for
 * encrypted lookups .
 * <p>
 * The IV is not random; it is synthetically generated by applying HMAC-SHA256
 * to the plaintext using a dedicated HMAC key. This construction is known as a
 * Synthetic IV (SIV) approach and provides integrity protection. The output
 * ciphertext is structured as {@code [IV (16 bytes)] + [Encrypted Data]}.
 *
 * @see BytesCipher
 */
public class AesSivCtrBytesCipher implements BytesCipher
{

    private final Kripto kripto;
    private final Hmac hmacHash;
    private final SecretKey hmacKey;
    private final SecretKey encryptionKey;

    // AES uses a 128-bit (16-byte) IV for CTR mode.
    private static final int AES_IV_BITS = 128;
    private static final int AES_IV_LENGTH = AES_IV_BITS / 8;

    /**
     * Constructs a DeterministicAesCtrBytesCipher with a default Kripto
     * instance.
     *
     * @param hmacKey The secret key used to generate the synthetic IV via Hmac.
     * @param encryptionKey The secret key used for AES-CTR encryption. It is
     * strongly recommended that this key be different from the hmacKey.
     */
    public AesSivCtrBytesCipher(Hmac hmacHash, SecretKey hmacKey, SecretKey encryptionKey)
    {
        this(hmacHash, hmacKey, encryptionKey, null);
    }

    /**
     * Constructs a DeterministicAesCtrBytesCipher with a provided Kripto
     * instance.
     *
     * @param hmacKey The secret key used to generate the synthetic IV via Hmac.
     * @param encryptionKey The secret key used for AES-CTR encryption.
     * @param kripto An optional Kripto helper instance. If null, a default
     * instance is created.
     */
    public AesSivCtrBytesCipher(Hmac hmacHash, SecretKey hmacKey, SecretKey encryptionKey, Kripto kripto)
    {
        if (hmacKey == null)
        {
            throw new IllegalArgumentException("hmacKey cannot be null for a deterministic cipher.");
        }
        this.kripto = kripto == null ? Kripto.getInstance() : kripto;
        this.hmacHash = hmacHash;
        this.hmacKey = hmacKey;
        this.encryptionKey = encryptionKey;
    }

    /**
     * Encrypts the given plaintext deterministically using AES-CTR with a
     * synthetic IV. The IV is generated via HMAC-SHA256 of the plaintext and is
     * prepended to the ciphertext.
     *
     * @param plaintext The byte array to be encrypted.
     * @return The deterministic ciphertext, formatted as [IV] + [Encrypted
     * Data].
     * @throws Exception if any cryptographic error occurs during encryption.
     */
    @Override
    public byte[] encrypt(byte[] plaintext) throws Exception
    {
        // 1. Generate a synthetic, deterministic IV by applying Hmac to the plaintext.
        byte[] iv = Arrays.copyOf(kripto.getHMAC(hmacHash).digest(hmacKey, plaintext), AES_IV_LENGTH);

        // 2. Prepare the parameters for AES-CTR.
        IvParameterSpec ivSpec = new IvParameterSpec(iv);

        // 3. Perform encryption using AES-CTR.
        byte[] encryptedData = kripto.encrypt(encryptionKey, SecretKeyTransformation.AES_CTR_NoPadding, ivSpec, plaintext);

        // 4. Prepend the synthetic IV to the ciphertext.
        ByteBuffer byteBuffer = ByteBuffer.allocate(iv.length + encryptedData.length);
        byteBuffer.put(iv);
        byteBuffer.put(encryptedData);
        return byteBuffer.array();
    }

    /**
     * Decrypts the given ciphertext and verifies its integrity. It expects the
     * input to be formatted as {@code [IV] + [Encrypted Data]}.
     *
     * @param ciphertext The byte array to be decrypted.
     * @return The original plaintext byte array.
     * @throws Exception if decryption fails.
     * @throws SecurityException if the integrity check fails, indicating data
     * tampering.
     */
    @Override
    public byte[] decrypt(byte[] ciphertext) throws Exception
    {
        ByteBuffer byteBuffer = ByteBuffer.wrap(ciphertext);

        // 1. Extract the synthetic IV from the beginning of the ciphertext.
        byte[] iv = new byte[AES_IV_LENGTH];
        byteBuffer.get(iv);

        // 2. Extract the encrypted data payload.
        byte[] encryptedData = new byte[byteBuffer.remaining()];
        byteBuffer.get(encryptedData);

        // 3. Prepare parameters and decrypt the payload.
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        byte[] decryptedPlaintext = kripto.decrypt(encryptionKey, SecretKeyTransformation.AES_CTR_NoPadding, ivSpec, encryptedData);

        // 4. CRITICAL: Verify integrity. Recalculate the IV from the decrypted plaintext
        // and ensure it matches the IV that was sent with the ciphertext.
        byte[] expectedIv = Arrays.copyOf(kripto.getHMAC(hmacHash).digest(hmacKey, decryptedPlaintext), AES_IV_LENGTH);

        // Use a constant-time comparison to prevent timing attacks.
        if (!MessageDigest.isEqual(iv, expectedIv))
        {
            throw new SecurityException("Integrity check failed. The data may have been tampered with.");
        }

        return decryptedPlaintext;
    }
}
